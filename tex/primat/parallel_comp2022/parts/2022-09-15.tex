\documentclass[main.tex]{subfiles}
\begin{document}
	glib использует интерфейс Си.
	Это синхронный запуск подчинённого процесса.

\begin{verbatim}

int g_spawn_failed = 0;
standard_output = NULL;
standard_error = NULL;
	
\end{verbatim}

Кроме \texttt{g\_spawn\_sync} есть \texttt{g\_spawn\_async}:
тогда исполнение \texttt{if} исполняется параллельно со следующим кодом.

Исполнение \texttt{if} должен кто-то ждать.
Для этого заводим mutex.

\begin{leftbar}
	mutex -- объект, связанный с ресурсом.
	Порядок работы с мутексом такой: ресурс нужно захватить, работу с ним сделать и тут же отдать.
\end{leftbar}


Есть более высокоуровневый аналог в \texttt{boost}:

\begin{verbatim}

namespace bp = boost::process;
bp::ipstream is;
string output;
...

\end{verbatim}

В Python -- модуль \texttt{subprocess}: subprocess.run

То же есть в R (system)

\subsection{Пул потоков}

Thread Pool -- есть фреймворки во всех языках.
Ему просто передаём число потоков, которое разрешаем открыть максимально, после чего в этой конструкции (где, кроме потоков, есть очередь задач) задачи достаются из очереди задач и распределяются в процессы.

В multiprocessing (Python) есть ThreadPool!

Ограничение: при организации ThreadPool распараллеливаемая функция может иметь только один параметр.

\subsection{MPI}

Message Passing Interface (система передачи сообщений): в 80-е годы постепенно начала развиваться, к 92-му году её смогли начать стандартизировать.
К этому времени традиционные компьютеры стали приближаться к пределу производительности, и стали появляться кластеры Beowulf (из нескольких узлов). \\

OpenMPI -- реализация MPI с открытым исходным кодом.
Поддерживает различные коммуникационные среды (<<интерконнекты>> -- например, Infiniband, как в Политехе).

Для правильного запуска MPI-кода вместо компилятора используем  <<обёртку>>  \texttt{mpicc}, которая специальным образом настраивает обычный компилятор.

\begin{verbatim}

#include<mpi.h>
#include<stdio.h>

int main(int argc, char * argv[])
{
	int numtasks, rank, rc;
	
	rc = MPI_Init(&argc, &argv);
	
	<...>
	
	MPI_Finalize();
}

\end{verbatim}

Запуск: \texttt{mpirun -np 3 -host venus,mars,saturn ./check\_prime 99990001}

Аргументы передаются в \texttt{MPI\_Init} \\

Сообщением называется какой-то кусок данных вместе со служебной информацией.
Там содержится в том числе тип (но MPI переопределяет типы).

В простейшем случае мы пересылаем массив (к примеру, целых или дробных чисел) + состояние процессов.
Сообщение передаётся через буферы; если не удаётся выделить буфер достаточного размера

\subsubsection{ Инициализация и финализация MPI-программы }

MPI\_Finalize закрывает все коммуникаторы, буферы...

\end{document}