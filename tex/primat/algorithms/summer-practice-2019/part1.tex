\documentclass[zuev-report.tex]{subfiles}
\begin{document}
	
\section{Постановка задачи}
Задан неориентированный нумерованный граф $G(V, E)$: $p = |V|, q = |E|$ - число вершин и рёбер соответственно. Каждому узлу сопоставлен номер от $0$ до $p - 1$. В текстовом файле задано множество рёбер: в первой строке - число $p$, во второй - число $q$, далее на $q$ строках размещены пары чисел $(u, v)$, разделённые пробелами, $u, v \in V, (u, v) \in E$\\
Задача: построить списки вершин, содержащие связные компоненты графа. Вывести списки на экран.\\
Требуется разработать алгоритм, основываясь на операциях с непересекающимися множествами. Операции реализовать на списке.\\

\newpage
\section{Описание алгоритма}
Алгоритм, реализованный программой на языке Си, состоит из двух этапов:
\begin{enumerate}
	\item чтение списка рёбер графа из файла
	\item составление списков вершин, находящихся в одинаковых компонентах связности. Используется структура данных \textit{система непересекающихся множеств (СНМ)}, поддерживающая операции инициализации множества из одного элемента и объединения множеств.
\end{enumerate}
\subsection{Чтение графа}
Вначале граф представлен массивом рёбер. Для чтения множества рёбер используется двумерный массив $q\times 2$. Написаны функции \lstinline|int ** graphMemAlloc(int q)|  -- выделяет память для хранения массива рёбер, \lstinline|void graphRead(int q, int ** graph, FILE * fin)| -- считывает данные из файла,  \lstinline|void graphMemFree(int q, int ** graph)| -- освобождает память после использования графа.

\subsection{Релизация СНМ}
Система непересекающихся множеств - структура данных, хранящая множества неповторяющихся значений (например, различных целых чисел) и поддерживающая операции создания множества из одного элемента, объединения двух множеств, выдачи всех элементов множества по его \textit{представителю}. Представитель множества - некий его элемент, выделенный среди остальных, который используется как уникальный идентификатор множества.\\
Элемент множества представлен структурой \lstinline|struct Node| (она же \lstinline|node_t|) с полями \lstinline|int data; struct Node * next; struct Node * head|. Здесь целое число data - номер узла графа, head - указатель на первый элемент списка, который и является представителем множества. \\
Основная операция над непересекающимися множествами -- \lstinline|void unite(node_t * a, node_t * b)| -- объединение. Эта процедура работает следующим образом:\\

\begin{enumerate}
	\item определяется указатель "`aHead"' на представителя множества, содержащего "`a"'
	\item "`a"' приравнивается к следующему элементу в цикле до тех пор, пока следующий элемент не будет равен NULL, т. е. "`a"' становится указателем на последний элемент множества.
	\item "`b"' приравнивается к указателю на представителя своего множества, после чего следующим за "`a"' элементом объявляется "`b"' -- списки объединяются
	\item В цикле до тех пор, пока "`b"' не NULL, указатель "`b->head"' приравнивается к "`aHead"' и "`b"' приравнивается к "`b->next"' -- всем элементам бывшего множества, содержавшего "`b"', "`aHead"' назначается представителем
\end{enumerate}
Инициализация множества -- \lstinline|node_t * initSet(int data) | -- аллокация памяти для одного элемента Node. Пользователь должен самостоятельно следить за тем, чтобы не создавались элементы с одинаковыми полями data.\\
Для удобства хранения указателей на различные множества определена структура DSU с полями \lstinline|int nUnions; node_t ** unions|: nUnions - число множеств, unions - массив указателей на представителей.\\

\subsection{Вычисление компонент связности}
Функция \lstinline|dsu_t toDSU (int ** graph, int p, int q)| по заданному массиву рёбер вычисляет компоненты связности. Ниже приведён алгоритм, заложенный в функции:
\begin{enumerate}
	\item Создаётся массив указателей \lstinline|node_t ** allNodes| и заполняется значениями NULL
	\item Для всех рёбер - пар $(u,v) \in E$:
	\begin{enumerate}
		\item Для $u, v$ создаются новые одноэлементные множества, если ещё не заняты (равны NULL) AllNodes[u] и AllNodes[v] соответственно. Указатели на эти множества помещаются в AllNodes[u] и AllNodes[v]
		\item вызывается операция слияния множеств \lstinline|unite(u, v)| 
	\end{enumerate}
\end{enumerate}
\end{document}