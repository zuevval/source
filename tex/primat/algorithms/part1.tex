\documentclass[zuev-23631-2-report.tex]{subfiles}
\begin{document}
\section{Постановка задачи}
Задача - реализовать динамические множества с сохранением предыдущих версий.\\
Некое множество $S \in \mathds{N}$  организовано в виде дерева двоичного поиска. Дерево двоичного поиска --  бинарное дерево, у каждой вершины которого все ключи элементов в левом поддереве меньше ключа самой вершины, а в правом - больше (в дереве нет элементов с одинаковыми ключами). Левым сыном элемента будем называть корень левого поддерева, правым сыном -- корень правого.\\ 
Требуется реализовать возможность добавления и удаления элементов с сохранением предыдущих версий дерева. Для экономии времени и памяти необходимо не создавать всякий раз новое дерево, а хранить только изменённое поддерево и путь от корня до этого поддерева. Пример показан на рисунке \ref{ins1}: в исходное дерево (белые элементы) вставляется элемент (3). Создаются зелёные элементы и новой версии сопоставляется свой корень.\\
\begin{figure}[H]
\center{\includegraphics[width=.6\textwidth]{pictures/tree_insert1.png}}
\caption{Добавление ключа с сохранением предыдущей версии}
\label{ins1}
\end{figure}
Изначально дерево пустое. Необходимо реализовать поддержку команд:
\begin{itemize}
\item{<<+ [неотрицательное целое число]>>} - добавить ключ
\item{<<- [неотрицательное целое число]>>} - удалить ключ
\item{<<? [неотрицательное целое число]>>} - указать, есть ли в дереве элемент с заданным ключом
\item{<<u>>, <<U>>} - вернуться к предыдущей версии множества
\item{<<r>>, <<R>>} - вывести ключ корня дерева
\item{<<\#>>} - вывести количество элементов в множестве
\end{itemize}
\section{Описание алгоритма}
\subsection{Хранение дерева и его версий}
Используется связное представление. Каждый узел дерева - структура (struct Node) с полями: ключ (data), версия, в которой был добавлен этот элемент (vers), указатель на левого сына (l) и на правого сына (r). Программа хранит в памяти номер текущей версии и массив из суперкорней дерева. Суперкорнем будем называть элемент со значением -1, невидимый для пользователя. Суперкорень добавлен для унификации операций с деревом (дерево никогда не пусто). Поскольку ключи  в видимом пользователю дереве неотрицательные, видимый корень всегда будет правым сыном суперкорня.
\subsection{Поиск в дереве и подсчёт элементов}
Функция поиска использует структуру дерева двоичного поиска. Во временную переменную помещается указатель на узел (вначале - суперкорень дерева). Если ключ узла равен искомому, функция прекращает поиск и возвращает единицу (элемент найден). Если ключ узла больше искомого и правое поддерево пусто, возвращается -1 (элемент отсутствует); если больше, но поддерево не пусто, приравниваем временную переменную к указателю на правого сына. Аналогично, если ключ узла меньше искомого, рассматриваем левое поддерево.\\
Поиск реализован в функции "findNode"\hspace{0pt} (раздел \ref{functions}, строка \ref{line:findNode}).\\

\subsection{Добавление в дерево}

Вводятся временные переменные n1 (вначале суперкорень дерева) и t (вначале суперкорень дерева предыдущей версии). В случае, когда добавляемое значение меньше ключа n1, проверяется левое поддерево t (оно же левое поддерево n1): 
\begin{itemize}
\item{}Если пусто, добавляем левого сына n1 -- новый элемент со значением, равным добавляемому и версией, равной новой версии и завершаем работу функции. 
\item{}Если не пусто, инициализируем новый узел со значением, равным значению ключа левого сына t и версией, равной новой версии (копируем узел); устанавливаем левого сына n1 равным указателю на новый узел; приравниваем t к левому сыну t, n1 к левому сыну n1; продолжаем обход.
\end{itemize}
В случае, когда добавляемое значение больше ключа n1, проделываем те же операции над правым поддеревом.\\
Добавление версии с новым элементом реализовано в функции "newVersPush"\hspace{0pt} (раздел \ref{functions}, строка \ref{line:newVersPush}).\\

\subsection{Удаление из дерева}

Используются временные переменные n1, t, n1parent (указатели на узлы) и n1IsSon (индикатор того, каким сыном является узел n1 - левым или правым).\\
Вначале, как и при добавлении нового элемента, устанавливаем n1 равным указателю на суперкорень дерева создаваемой версии, t - суперкорню предыдущей. Затем, пока ключ t не станет равным удаляемому ключу, t приравнивается к указателю на какого-то из своих сыновей (как при поиске элемента). На каждом шаге соответствующий сын n1 изменяется на копию сына t с новым значением версии, после чего n1 приравнивается к указателю на своего нового сына (как при создании версии с добавлением элемента). Помимо этого, на каждом шаге значение n1parent приравнивается к бывшему значению n1 и изменяется n1IsSon.\\
После того, как определён удаляемый элемент:
\begin{itemize}
\item{} Если один из сыновей n1 пуст, то вместо n1 к сыну n1parent приравнивается бывший непустой сын n1, а элемент n1 удаляется (освобождается) (см. рис. \ref{treeRemove1}); функция завершает работу.

\begin{figure}[h]
\center{\includegraphics[width=\textwidth]{pictures/tree_remove1.png}}
\caption{Удаление элемента при отсутствии сына}
\label{treeRemove1}
\end{figure}

\item{} Если оба сына непустые, инициализируется новый узел n2, куда копируется левый сын t (с изменением версии на новую). Левый сын n1 приравнивается к n2, t приравнивается к указателю на своего левого сына. Теперь n2 в новой версии соответствует t в старой. Далее:
\begin{itemize}
\item{}Если правый сын t пустой (и, следовательно, левый сын n2 - наибольший из всех элементов слева от n1, за исключением n2), ключ n1 приравнивается к ключу n2; левый сын n1 приравнивается к левому сыну n2 (правый сын n2 пуст, как и правый сын); n2 освобождается  (см. рис. \ref{treeRemove2}).

\begin{figure}[H]
\center{\includegraphics[width=\textwidth]{pictures/tree_remove2.png}}
\caption{Удаление элемента при наличии обоих сыновей и отсутствии правого сына левого сына}
\label{treeRemove2}
\end{figure}

\item{}Если правый сын t не пуст, то, пока правый сын правого сына t не пуст, выполняются операции: правый сын n2 приравнивается к копии правого сына t; n2 приравнивается к указателю на своего правого сына; t приравнивается к указателю на своего правого сына.\\
Как только правый сын правого сына t пуст (и, следовательно, правый сын t содержит наибольший ключ среди всех ключей левого поддерева n2), приравниваем ключ n1 к ключу правого сына t, а правого сына n2 приравниваем к левому сыну t вне зависимости от того, пуст последний или не пуст  (см. рис. \ref{treeRemove3}). Выходит, что удаляемый элемент - правый сын t, но удаляемый ключ - ключ n1. Освобождать ничего не надо, т. к. правый сын t не был скопирован в новую версию, а в старой должен сохраниться.
\end{itemize}
\end{itemize}
Добавление версии с удалением элемента реализовано в функции "newVersPop"\hspace{0pt} (раздел \ref{functions}, строка \ref{line:newVersPop}).\\
\begin{figure}[h]
\center{\includegraphics[width=\textwidth]{pictures/tree_remove3.png}}
\caption{Удаление элемента при наличии обоих сыновей и наличии правого сына левого сына}
\label{treeRemove3}
\end{figure}

\subsection{Возврат к предыдущей версии и подсчёт числа узлов}

Для временного хранения узлов дерева при обходе выделяется массив, доступ к элементам которого организован по принципу стека (выдача данных в порядке, обратном добавлению). Далее этот массив будем называть просто "стек".\\
При возврате к старой версии более новая удаляется. Для этого используется стек. Совершается обход элементов дерева, добавленных в удаляемой версии. Сначала в стек помещается корень удаляемого дерева (если есть). Пока стек не пуст, из стека извлекается элемент; если элемент имеет детей, добавленных в той же версии, эти дети помещаются в стек; память, отведённая под элемент, освобождается.\\
Удаление реализовано в функции "removeVers"\hspace{0pt} (раздел \ref{functions}, строка \ref{line:removeVers}). \\
Подсчёт числа узлов также обходит дерево, используя стек. Отличие состоит в том, что не проверяется принадлежность элементов к какой-то версии. Вместо удаления элемента происходит увеличение счётчика, вначале равного нулю. Значение этого счётчика после обхода и есть результат. Заметим, что обход дерева происходит в прямом порядке (сперва вершина, затем её левое поддерево, затем правое поддерево).\\
Подсчёт реализован в функции "count"\hspace{0pt} (раздел \ref{functions}, строка \ref{line:count}). \\

\subsection{Взаимодействие с пользователем}

Пользовательский интерфейс опрделён в файле <<main.c>>. Ввод текста осуществляется построчно с клавиатуры. Результат выводится на экран.\\
В начале работы  в функции "main"\hspace{0pt} (раздел \ref{main}, строка \ref{line:main}) выделяется массив элементов - суперкорней различных версий. По команде <<q>> вся память, выделенная под структуру, освобождается и программа завершает работу. Если команда отлична от <<q>>, введённая строка передаётся в функцию "processInput"\hspace{0pt} (раздел \ref{main}, строка \ref{line:processInput}), которая проверяет корректность введённой команды. Затем, если команда соответствует известному типу, вызываются соответствующие функции из арсенала <<functions.h>>. Если пользователь просит удалить или добавить ключ, предварительно проверяется наличие или отсутствие ключа в текущей версии. Если введена команда возврата к предыдущей версии, проверяется наличие прошлый версий.

\newpage
\section{Текст программы, реализующей алгоритм}

Программа разделена на три файла. Файл main.c обрабатывает команды пользователя. Файл functions.c содержит функции, работающие со структурой (инициализация и освобождение узлов, поиск по узлам, копирование узлов, подсчёт элементов в дереве, создание новой версии с одновременным добавлением или удалением элемента); файл functions.h содержит необходимые макроопределения (в частности, максимально допустимое число версий и максимально допустимую глубину дерева в одной версии), а также определения тех функций из functions.c, которые вызываются в main.c.
\lstset{
language=c,
keywordstyle=\color{blue},
%commentstyle=\color{},
%stringstyle=\color{red},
tabsize=1,
breaklines=true,
columns=fullflexible,
numbers=left,
escapechar=@}

\subsection{Файл <<functions.h>>}
\lstinputlisting{code/functions.h}

\subsection{Файл <<functions.c>>}
\label{functions}
\lstinputlisting{code/functions.c}

\subsection{Файл <<main.c>>}
\label{main}
\lstinputlisting{code/main.c}

\newpage
\section{Описание тестирования}
С помощью библиотеки Google Test Framework были составлены семь тестов, моделирующих различные ситуации и контролирующих поведение функций инициализации структуры, добавления в структуру, удаления и освобождения версий в этих ситуациях. Последний тест (строка \ref{line:pushPopRollBack}) последовательно тестирует операцию добавления, удаления и отката на версию назад.\\
Контроль утечек памяти был осуществлён при помощи программы valgrind.\\

\section{Текст тестирующей программы}
\lstinputlisting{code/tests.cpp}
\newpage
\section{Результаты тестирования алгоритма}
Все тесты пройдены (рис. \ref{testPict}). Утечек памяти нет.
\begin{figure}[H]
\center{\includegraphics[width=\textwidth]{pictures/tests.png}}
\caption{Результаты тестирования}
\label{testPict}
\end{figure}

\newpage
\section{Выводы}
Используя представление множества в виде деревьев, можно усовершенствовать не только поиск по заданному ключу, но и хранение версий множества. Если каждому элементу сопоставить строку в некотором разбитом на строки текстовом документе, можно создать несложную систему контроля версий.\\
В данной работе реализован простейший алгоритм, позволяющий хранить различные версии множеств. Этот алгоритм наверняка может быть улучшен. На практике элементы множества (к примеру, те же строки в текстовом файле) часто поступают последовательно по возрастанию или убыванию ключа, отчего дерево может в предельном случае выродиться в список. В таком случае не только замедляется поиск по дереву, но и операция добавления в конец этого дерева или удаления из конца не выигрывает по времени и памяти по сравнению с простым копированием множества. Интересной задачей может стать оптимизация структуры данных с поддержкой предыдущих версий.\\
\end{document}