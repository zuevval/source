\documentclass[main.tex]{subfiles}
\begin{document}
	
\section{Лекция 7. Когда не надо применять ML + Видеонаблюдение}
18 марта 2021 г.

\subsection{Попытки применить ML, когда не надо}

Люди (заказчики) думают, что машинное обучение модно, и поэтому пытаются применить его, не понимая, что она лучше и быстрее решается без неё.
Часто такие заказчики не имеют в своей компании соответствующей инфраструктуры, компьютеров, серверов; в итоге тратится много сил, времени и ничего не получается.
В итоге этот заказчик в следующий раз, когда ML действительно может быть полезно, побоится его использовать.

Примеры:

\begin{enumerate}[noitemsep]
	\item в задаче нет семантического разрыва (например, расчёт выручки по известным ценам закупки, продажи и стоимостям обслуживания).
	
	Важное исключение: инфраструктура позволяет обучить ML быстрее, чем строить точную модель.
	Например, если у нас большая компания (Яндекс) со сложной инфраструктурой, где для расчёта стоимости можно использовать приближённые модели (и уже отработанные пайплайны обучения ML-моделей, т. о. достаточно взять уже готовые данные и нажать на кнопку, чтобы обучить).
	\item Все объекты в задаче хорошо описываются формулами.
	
	Пример: хотим сравнить два алгебраических выражения -- равны они или не равны?
	
	Машинное обучение пытается подобрать зависимости в данных, когда мы их ещё не видим, описать, что происходит в данных.
	Если формулы заранее известны, вряд ли мы их сделаем точнее.
	
	Хотя иногда можно, к примеру, сложную формулу аппроксимировать полиномом.
	
	\item Нет хороших ML-моделей, которые описывают нашу ситуацию
	
	Если задача плохо описывается нейронными сетями, деревьями решений и т. д., то вряд ли мжоно подобрать очень хороший алгоритм.
	Люди часто пытаются притянуть модель к задаче за уши (например, в задаче с формулами: просто сказать, что формула -- последовательность текста: очень плохо; формула как дерево, в рёбрах которого операции -- уже чуть лучше, но всё равно вряд ли будет работать).
	
	\item Трудно получить хорошие данные (это частая ситуация)
	\begin{enumerate}[noitemsep]
		\item Трудности с качественной разметкой: не всегда в открытом доступе есть датасет, подходящий нам; если есть, то не всегда размечено так, как нам нужно.
		
		Возможно, мы получим подходящий датасет только когда уже запустим сервис, придут пользователи и появятся примеры данных.
		\item Трудности из-за приватных данных: например, мы делаем программу для заказчика, который не хочет давать нам обучающие данные из-за секретности.
		
		Пример: данные о банковских транзакциях.
		Банк вряд ли может передать нам данные без обфускации.
	\end{enumerate}
	Если нет хороших данных, обучать ML-модель бесмыссленно, потому что она будет работать не лучше, чем эти данные.
	Может быть, имеет смысл отобрать небольшое количество подходящих примеров, построить алгоритм без ML и тестировать на них.
	
	\item Необходимо понимать принципы работы полученного алгоритма
	
	В одном дереве можно разобраться, как оно работает; лес решений уже сложно анализировать, вряд ли сможем предсказать выход, глядя на структуру,
	
	Клиент часто хочет понимать, что как работает.
	Например, приходит клиент в банк и спрашивает, почему заблокировали вполне нормальную банковскую операцию?
	<<ML-модель заблокировала>> -- плохой ответ.
	<<У нас есть решающее правило, основанное на сумме операции и т. д.; сейчас мы его подправим для Вашего случая>> -- ответ хороший.
	
	\item Большая устойчивость к взламыванию
	
	Зачастую можно подобрать такое видоизменение входных данных, что ML-модель начнёт на нём ошибаться.
\end{enumerate}

Помимо прочего, задачи применения ML обычно не очень интересные.

\subsection{SHAP-диаграммы}

Как лучше понимать, что мы получили после обучения нейросети?

Если есть, к примеру, нейронная сеть, полезно понять, в каких слоях обучаются какие промежуточные признаки, чтобы лучше понимать семантическую сущность.
Тогда легче локализовывать ошибки: ожидать, к примеру, что в одной группе слоёв будут находиться границы, в конце второй -- особые точки, потом объекты...


Будет много проблем с метриками качества: сложно вручную определить для большого изображения, насколько хорошо в каждом слое определяются признаки.

Есть способы попытаться промоделировать, как ведёт себя модель при изменении значений признаков.
Идеологически наиболее правильный способ -- \textbf{SHAP-диаграммы}: на вход подаются признаки, на выходе -- их вклад в ответ ML-системы.

\href{https://github.com/slundberg/shap}{github.com/slundberg/shap}

Чем цвет точки теплее, тем больше её значение.
Положение точки по оси абсцисс показывает её вклад; вблизи нуля -- значит, ответ ML-модели слабо коррелирует со значением признака.

Есть теорема, из которой следует, что SHAP-модели -- наиболее правильный способ описания влияния признаков на ответ.

SHAP-value -- из теории игр.

Для каждого признака $ i $ и каждого примера в данных считаем предсказание на нём с признаком и без признака.
Перебирать все признаки и все данные, конечно, трудоёмко; но, к примеру, в Яндекс SHAP-диаграммы, как правило, строятся для существенной доли обучающей выборки.

\subsection{Обработка видео. Постановка задачи}

\subsubsection{Видео}

Работая с видео, мы предполагаем, что объекты между соседними кадрами изменяются незначительно.

Критерии <<незначительности>> могут варьироваться.

Видео может помочь повысить точность распознавания: можно выбрать наиболее качественный кадр или использовать несколько соседних.
% TODO note for self: матрица гомографии, матрица калибровки; матрица поворота. Можно получить более точные размеры объекта.

\subsubsection{Задачи (на бизнес-уровне)}

Может быть медицинское обследование, навигация по контенту, поиск по видео...
Задач много!

\subsubsection{Задачи на более низком уровне (формализация)}

\begin{enumerate}[noitemsep]
	\item Выделение <<объектов интереса>>, которые мы описываем какими-то геометрическими примитивами (например, прямоугольниками) или попиксельными масками.
	\item Отслеживание (video tracking): часто имеет смысл отслеживать
	\item Поиск действий (физическое движение человека, взаимодействие объектов -- например, ключ вставлен в замок).
\end{enumerate}

\subsection{Обработка видео. Общие идеи}

В видео есть <<стабильные по виду>> объекты, которые можно отслеживать, и <<атомарные действия>>, котрые можно регистрировать.

\subsubsection{Проблемы}

\begin{enumerate}[noitemsep]
	\item Масштабируемость: видео обрабатывается гораздо медленнее одной фотографии
	\item Вид изменяется от кадра к кадру из-за изменения ракурса, освещения.
	\item Объекты могут накладываться; может быть несколько похожих объектов.
	\item Иногда может быть нестационарное положение камеры (в исследованиях, впрочем, обычно камера зафиксирована жёстко).
\end{enumerate}

\subsubsection{Оценка качества}

Оценки качества, как правило, сводятся к определению расстояния от размеченной нами <<правды>> (ground trugh) до того, что нашёл алгоритм, или ожидаемая ошибка на видеопоследовательности...

\subsubsection{Ситуация 1. Стабильный фон. Вычитание фона}

Пусть есть объект на фоне и фон стабильный, не смещается и не изменяется.
Можно определить, сравнивая с пороговом значением какие пиксели принадлежат интересующим нам объектам, и вычесть все остальные пиксели из изображения.
Порог -- параметр алгоритма.

\subsubsection{Обработка маски переднего плана после вычитания фона. Мечты}

Чтобы выделить объекты, разумно фильтровать шумы (и вообще использовать алгоритмы, похожие на то, что мы делаем с обычными изображениями -- поиск блобов и прочие).
Особенность: поскольку кадров много и часто нужно работать в режиме реального времени, нельзя применять алгоритмы, которые требуют слишком много времени (морфологию можно, детектор Харриса или Canny -- вряд ли).

\subsubsection{Изменяющийся фон}

В не-лабораторных условиях фон меняется (зависит от времени).

Можно построить график зависимости значений цвета, яркости в пикселях от времени; рассчитать на основе собранных данных

Можно не просто вычитать фон, а подобрать более сложную модель, по которой будем понимать, принадлежит ли пиксель фону (например, объект должен быть намного темнее фона).
Модели с классификациях в отдельных пикселях без контекста работают плохо.
Лучше использовать модели, которые сравнивают соседние пиксели.

\subsubsection{Простейшие модели фона}

Среднее / медиана всех изображений: плохо работает, если много движущихся объектов.

Можно принимать во внимание дисперсию.
Могут играть роль моменты более высокого порядка: третий, четвёртый.

Если в видео постепенно меняется освещённость, можно брать кадры с разными весами; можно строить распределение изменения освещённости.
Пиксели, которые удовлетворяют распределению, будем считать пикселями фона, остальные -- пикселями объектов.

Среди прочих идей: запоминаем, какое изменение вносят базовые объекты (например, включили/выключили лампу), учитываем это в модели.
Для этого можно использовать особые точки.

\subsubsection{Отслеживание объектов}

Пусть в кадре были несколько объектов.
Хотим сопоставить объекты на одном кадре объектам на соседнем.

В следующем кадре объекты могут появляться, исчезать и смещаться.

Интуитивная стратегия: искать на следующем кадре ближайшие точки, похожие на то, что в данной точке на текущем кадре.
Но это не очень хорошо работает: например, если много похожих объектов быстро движутся в одну сторону, легко ошибиться.

\subsubsection{Виды ограничений}

\begin{enumerate}[noitemsep]
	\item Близость -- естественное предположение: объект не может за один кадр переместиться на большое расстояние.
	
	\item Вводим максимальную скорость движения
	
	\item Ожидаем малое изменение вектора скорости
	
	\item Есть общая картина движения; возможно, все объекты движутся примерно в одном изображении
	
	\item <<Жёсткость>>: пути следования объектов вероятнее не пересекаются, чем пересекаются.
\end{enumerate}

Как это учитывать?
Можно построить двудольный граф возможных соответствий между объектами в одном и в другом кадре, присвоить рёбрам веса и выбрать какое-то их подмножество.

\subsubsection{Базовый метод видеонаблюдения}

\begin{enumerate}[noitemsep]
	\item Обучаем модель фона (и, возможно, модель объекта)
	\item Для каждого кадра
	\begin{enumerate}[noitemsep]
		\item вычитаем фон (для каждого пикселя смотрим, он больше похож на фон или на объект?)
		\item уточняем объект
		\item ассоциируем объекты в треки
		\item Инициализируем
		\item обновляем фон, если для этого есть основания.
	\end{enumerate}
\end{enumerate}

Пример -- отслеживание руки с помощью <<стаи точек>>.

Модель <<стая точек>>: никакие две особенности не совпадают (точки не находятся слишком близко друг к другу), особые точки не находятся слишком далеко от центра (иначе они обрезаются).

Особые точки могут обучаться, или выбираться случайно, или по критерию (например, по цвету).
Центр есть медиана всей стаи.

\subsection{Обработка видео. Оптический поток}

Когда обнаруживаем руку, считаем, что большая часть точек (фон) не движется.
Бывает, что движутся почти все точки (оптический поток).

Ищем векторное поле движения пикселей между кадрами.
Считаем, что точки объекта / не объекта контрастные.

\subsubsection{ Оценка оптического потока. Ограничения }

Будем считать, что яркость постоянная и смещение малое (меньше одного пикселя по каждой оси).

Тогда можно разложить в каждом пикселе картинку как функцию времени в ряд Тейлора:

$ I(x + u, y + v) = I(x,y) + \frac{\partial I}{\partial x} u + \frac{\partial I}{\partial y} v + <higher terms> \approx I(x,y) + \frac{\partial I}{\partial x} u + \frac{\partial I}{\partial y} v $

Есть \textbf{алгоритм Лукаса-Канаде }.

Элементарное уравнение оптического потока:
$$ 0 = I_t + \nabla I \cdot [u v] $$
(1 уравнение и 2 неизвестных для каждого пикселя).
Можно получить больше уравнений, задав ограничения:
для всех пикселей $ p $ в окрестности данного пикселя $ (x,y) $ смещение $ (u,v) $ постоянно.
Например, если выберем окрестность $ 5 \times 5 $:

$$ \underset{\text{обозначим как } A_{25 \times 2}}{
	\begin{pmatrix}
	I_x(p_1) & I_y(p_1) \\
	\vdots & \vdots \\
	I_x(p_{25}) & I_y(p_{25}) \\
	\end{pmatrix} }
\begin{pmatrix}
u \\ v
\end{pmatrix} = - \begin{pmatrix}
I_t(p_1) \\ \vdots \\ I_t(p_25)
\end{pmatrix} $$

Алгоритм Лукаса-Канаде: подбираем значения неизвестных методом наименьших квадратов.

\subsubsection{Проблема апертуры}

Матрица $ A $ не должна быть плохо обусловленной (в реальности не всегда матрица $ A $ хорошая).
Например, на каждом кадре прямая, проходящая через весь кадр.
Мы не можем понять, сдвинулся ли объект, который обозначает эта прямая, вдоль прямой или нет (уравнение имеет бесконечное количество решений).

\subsubsection{Особенности метода Лукаса-Канаде}

Предполагаем, что $ A^TA $ -- обратимая матрица.
Предполагаем также, что на картинке мало шума.

Если яркость кадров непостоянная, или соседние точки движутся по-разному, или скорость движения высока -- алгоритм применять не нужно.

\subsubsection{Итеративный алгоритм Лукаса-Канаде}

\begin{itemize}[noitemsep]
	\item оцениваем движение в каждом пикселе, решая уравнение методом наименьших квадратов
	\item преобразуем изображение, используя вычисленное движение % TODO ask: how?
	\item Повторяем предыдущие пункты, пока не сойдёмся к чему-то
\end{itemize}

Здесь не учитывается то, что нам, возможно, ещё требуется найти сам участок, в котором происходит движение и мы хотим применять алгоритм.

\subsubsection{Пример решения задачи: отслеживание положения объекта в реальном времени}

Есть книга; хотим понимать, как меняется её ориентация на видео.

Будем использовать дерево решений.
В каждом узле используем какое-то линейное правило для выбора пути.

Если обучить множество деревьев, их комбинация может работать существенно лучше.
Идея в том, что разбиения можно выбирать, минимизируя ошибку градиентным бустингом, а можно просто с элементами случайности обучить несколько деревьев и использовать их консенсус. Так приходим к алгоритму \textbf{Random Forest} (случайный лес).

Random Forest обучается быстрее, чем градиентный бустинг, довольно прост в реализации и является одним из наиболее распространённых алгоритмов классификации. \\

В нашей задаче отслеживания положения объекта можно найти $ N $ особых точек объекта, искать их на изображении и сделать классификатор, который найденным особым точкам будет присваивать номера от $ 0 $ до $ N $ (0 -- если не нашли соответствие).

Для этого возьмём исходное изображение объекта, найдём на нём особые точки (к примеру, детектором Харриса), отберём наиболее надёжные точки и обучим решающий лес для их классификации.

Дальше слежение: будем находить ключевые точки в видео быстрым (пусть и не очень точным) алгоритмом и классифицировать.

Зная положение точек, можно построить матрицу трансформации и понять, как объект ориентирован.
Точки в дереве решений можно сравнивать, к примеру, по яркости, по другим признакам...
Выбираем самые существенные признаки.

Сравнение яркостей, конечно, имеет смысл для двух близких точек, а не для одной точки делать сравнение с пороговым значением.

\subsubsection{Yet Another Keypoint Detector}

Идея: рассматриваем окрестность вокруг точки.
Если на диаметре, проходящем через точку, найдутся точки другого цвета, чем сама точка, считаем её особой.

Особые точки, вероятно, находятся не так точно, как в детекторе Харриса, но зато быстро.

Когда будем искать поворот, необязательно точно находить все особые точки и избегать обнаружения лишних.
Ведь цель -- всего лишь определить ориентацию объекта, случайные выбросы нивелируются правильно найденными точками.

\subsubsection{ Синтез данных }

Хотим найти подобрать данные, на которых обучим классификатор исходных точек.
Одного изображения явно недостаточно, чтобы построить хороший случайный лес.

Будем строить трёхмерную модель объекта, приближая объект сеткой.
После этого рендерим новые виды объекта с других ракурсов.

При обучении алгоритма авторы используют два подхода: целевая функция зависит от ошибок классификации

\subsubsection{ Результаты }

Если существенно движется большая часть изображения, надо искать оптический поток.

На изображении можно искать изменяющиеся объекты; пытаться сопоставить их с тем, что мы хотим увидеть (поворот ключа в замочной скважине, проход человека через дверь...)

\subsection{ Организационные моменты }

В отчёте по большой лабораторной хочется увидеть все шаги: постановку и план, какие алгоритмы строили и какие у них были проблемы и как их решали.

Отчёт лучше всего в readme.
Просьба: хорошо написать отчёт, т. к. у Виктора Игоревича нет возможности разбираться во всех реализациях.

Ревью: проект должен собираться и, желательно, корректно отрабатывать на представленном датасете.

Исправления, доделки, доработки можно оставить на средующую итерацию.
Возможны два варианта: получить все ревью, отправить письмо Виктору Игоревичу, получить за это первичные баллы и дальше доделывать + отправлять на второе ревью;

Критерии оценки за реализацию: алгоритм запускается; датасет репрезентативный; подробное описание, почему и как используем то или иное преобразование; дополнительные задачи.

Критерии оценки ревью: ВИ будет оценивать, насколько автор ревью разобрался в том, что происходит.
Просьба не придираться к коду.
Задача ревью -- скорее, не написать чистый код, а ревьюеру научиться понимать чужой код.

Есть возможность оспорить оценку за работу.
Как правило, в прошлые годы это была работа, которая была не в той ветке, а проверяющие этого не поняли.

\end{document}
